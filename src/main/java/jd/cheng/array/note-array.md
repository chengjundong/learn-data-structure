# 数组扩容和缩水
## 步骤
1. 创建一个新的数组
2. 原数据拷贝
3. 更改索性

## 触发条件及步长
### 扩容
当数组满，或者超过一定的阈值的时候扩容
步长一般以一倍为准，参考JDK的ArrayList实现
实际是考虑了内存消耗和扩容频率导致的性能损耗
### 缩水
当数组的长度不足一定长度，一般为一半时
步长考虑参考扩容

# 时间复杂度分析
## 例子
O(n)，又名线性关系，指算法运行时间与输入参数的个数呈线性关系  
然而，实际运行时间的功能可能如下所示  
`T = a*n + b`  
与输入参数有关的操作被重复了n次，每次时间为a;固定消耗是b  
在分析算法时间复杂度的时候，这些定值都可以忽略不计，所以就得到T与n呈正比，即线性关系
## O(n^2) 与 O(n)
举例，以下两个公式中，当n很小的时候，明显O(n^2)的时间要小  
1. T = 20000 * n + 100    
2. T = 1 * n^2 + 2  

**时间复杂度分析的是n趋近于无穷时候的情况**  
**实际使用中，可以根据n的实际情况来选择算法**，比如插入和快排，当数据很少的时候，应该使用插入而非快排
## 数组操作时间复杂度分析
### addLast -> O(1)
直接将size对应的位置的值赋值即可
### addFirst -> O(n)
需要先移动数组，再对第一个值赋值
### add(index, e) -> O(n)
通常都需要移动数组，简单来分析，可以认为是O(n)，严格计算要用概率论来计算出index的期望值
### remove
同add
### set, get
这是数组最大的优势，**支持快速随机访问**
- 已知索引，O(1)
- 未知索引，只知元素，O(n)。因为需要遍历搜索

### contains, find -> O(n)
都是基于数组遍历，所以都是线性复杂度
### 时间复杂度期望值
永远要用最坏情况分析一个算法的时间复杂度
## 均摊复杂度
addLast和removeLast的均摊复杂度都是O(1)  
因为每次addLast或者removeLast不可能都出发数组扩容或者缩水。均摊复杂度在工程上是很有意义的，**保证非常耗时的操作不会每次都出现**
## 复杂度震荡
当array的capacity全满的时候，交替执行addLast和removeLast，每次都会出现数组扩容或缩水，导致每次的复杂度都是O(n)。这就是复杂度震荡。  
**解决方案：**缩水操作需要lazy，而不是eager。具体方案是，当size是capacity的一半的时候，不要急着缩水，可以等到25%的时候再做