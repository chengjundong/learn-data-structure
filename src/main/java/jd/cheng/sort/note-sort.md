# Selection Sort 选择排序
平均时间复杂度，O(n^2)
## 步骤
1. 初始位置i=0
2. 遍历一遍，选择出最小的元素，放到位置i
3. i = i+1
4. 从i开始重复2~3步骤，直至排序完成

# Insertion Sort 插入排序
平均时间复杂度，O(n^2)
## 步骤
1. 数组长度为1，直接结束
2. 初始index = 1
3. 从index开始往前检查，是否存在比index位置小的数
4. 存在，则交换；直到遇到比它小的数字，结束
5. index自增1
6. 重复3~5，直到遍历完整个数组

## 改进
减少交换，采用挪动的方式改进
1. 将index位置的值保存为锚点（anchor）
2. 在步骤4中，将前一个数字与锚点进行比较，如果大，则将前一个数字移动到当前位置，小，退出当前循环
3. 遍历完成后，将锚点插入之前循环终止处

# Bubble Sort 冒泡排序
平均时间复杂度，O(n^2)
## 步骤
1. 从数组最后一个值开始，依次与前面一个比较
2. 如果比前面小，则交换；否则，终止单次循环
3. 对于剩余数组，采取同样的方式

## 改进
使用一个交换计数器，当发现比较一轮，无交换后，终止全部排序

# Shell Sort 希尔排序
平均时间复杂度，介于O(n^2) 与 O(nlogn)之间。  
可以认为是一种插入排序的改进。
## 步骤
1. 将输入数组取模，分为几个子数组
2. 对于子数组进行插入排序
3. 聚合子数组成为一个更大的子数组
4. 重复2~3，直到最后一轮，对整个数组进行一遍插入排序

利用了插入排序，在数组部分有序情况下，效率较高的特点。将数组切割为更小的，但有序的数组。不断聚合，重排。

# Merge Sort 归并排序
平均时间复杂度：O(nlogn)
- 将数组不断一分为二，直至每个元素一组。这样自顶向下，共有LogN层
- 每层的元素是固定的，N
- 每次归并，都需要开辟一个新数组，相比其他算法，空间消耗大

将所有层都处理完之后，排序结束。因此，时间复杂度是O(nlogn)

## 步骤
1. 递归将数组一分为二作为一层，不断重复直到只有最后一个元素为止。共有logn层。
2. 自底向上开始归并
3. 设置一个新数组，长度等于两个需要归并的数组长度之和
4. 一共需要三个指针
   - K：指向新数组头部
   - I：指向第一个需要归并的数组L的头部
   - J：指向第二个需要归并的数组R的头部
5. 比较I和J位置的数，小的就进到K的位置
   - 在K位置插入数字后，K+1
   - I和J，小的那个数字被归并进去后，自身指针+1
6. 重复2~5，直到所有层都处理结束

## 优化 1：避免归并已经有序的数组
在做归并前，检查两个数组的值  
如果，L的最大值 < R的最小值，无需归并

## 优化 2：当数组很小，自动转化为插入排序
因为当数组很小的时候，数组已经有序的概率比较大  
利用插入排序针对有序数组的时间复杂度为O(n)的特性 

# Quick Sort 快速排序
## 思路
选择一个数字，将它放在排完序后应有的位置。  
- 数字前的数都比该数字小
- 数字后的数都比该数字大

对于前后两部分，递归进行相同操作直至完成。上述操作叫做partition

## partition 步骤
1. 将数组第一个元素作为anchor
2. 尝试将数组分为partition 1 < anchor 以及 partition 2 >= anchor
3. 准备三个指针
   1. a -> 指向anchor
   2. b -> 指向parition 1 和 parition 2的分界处，border。即anchor最后的位置
   3. i -> 指向还未被归入任一partition的元素
4. 查看i位置的元素，比较其与anchor的大小
   1. 大，i++
   2. 小，将i位置的元素，与b位置的元素交换，i++，b++
5. 对partition 1 和 partition 2执行步骤1~4，直至整个数组全部排完

## 优化1: 随机选择anchor
对于anchor的选择，可以在区间内随机选取。

## 优化2：双路快排
解决分parition的时候，与anchor相同的值，会固定出现在某一个partition的问题
1. 取i=start+1，j=end，以anchor的值为参考，向数组中间逼近
   1. 若i位置的值小于等于anchor，i++
   2. 若j位置的值大于等于anchor，j++
2. 逼近结束，交换i，j位置的值，同时，i++，j--
3. 重复1和2，知道i的位置大于j
4. 此时j的位置，就是anchor应该在的
5. 交换anchor的值与j位置的值
6. 以j为边间，数据分成了两个partition，继续递归排序直到完成

## 优化3：三路快排
将数组分为三组：小于anchor的部分，等于anchor的部分，大于anchor的部分。  
只需要递归小于和大于的两部分即可。
