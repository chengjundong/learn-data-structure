# 线段树
应用场景，对于一个区间内的数据进行统计查询
- 查询 O(logn)
- 更新 O(logn)

不考虑向线段树中添加删除元素的操作，只考虑固定区间长度  
线段树是一棵平衡二叉树：最大深度 - 最小深度 = 1
## 分配空间
设，有n个元素，需要多大的数组才能存在对应的线段树呢？  
- n是2的k次幂，空间 = 2n
- n不是2的k次幂，空间 = 4n

### n = 2^k
线段树为满二叉树，叶子阶段为n个元素，需要空间：n  
假设叶子节点在第h层，则 2^h = n  
叶子节点以上， 2^0 + 2^1 + ... 2^(h-1) = 2^h - 1 = n - 1  
综上，叶子结点层需要n，以上需要n-1，其中-1忽略不计。总计2n个空间  

### n != 2^k
首先，先将最后一层去除，剩余的是一棵满二叉树，需要2n空间。已经在上面证明。  
假设最后一层空间为x, 根据上面的证明可以得到 2n = x - 1  
其中，-1同样忽略不计，则x = 2n。 也就是最后一层也需要2n空间。  
综上，最后一层需要2n，其上是一棵满二叉树，也需要2n，总计4n个空间  

### 叶子节点
判断叶子节点的标准就是，叶子节点的覆盖范围left == right

## 初始化
1. 需要输入一个`BiFunction`，代表如何得出两个节点融合后的值
2. 先用递归的方法将输入数据放到所有的叶子节点上
3. 依次自底向上，才用function将左子和右子融合
4. 最后到root

## 查询
设要查询[i, j]范围内的数据，即从tree的root开始向下递归查找这个区间覆盖的所有节点，并组合。  
算法复杂度与树的高度相关，所以是O(logn)

## 更新
1. 从root开始往下找
2. 找到原数组中所对应的元素，所在的叶子，将其更新
3. 从下往上再一次apply function，完成整颗树的更新