# 哈希表
维护一组映射关系，访问时间复杂度为O(1)。思想就是空间换时间。
- 哈希函数：将“键”转换为索引
- 哈希冲突：不同的“键”，经过hash后变为相同的索引

哈希表就是处在这两种极端情况内
- 无限空间，O(1)，所有数据完美散开
- size=1的空间，O(n)。所有数据都挂在一个索引下

## 哈希函数
### 基本的设计
- 小正整数：直接使用
- 小负整数：offset
- 大正整数：取模
  - 相对较好的一个解决办法：取模一个素数
  - goodhashtableprmies: 查看素数选择
- 浮点数
  - 例如，64位浮点型，将64位数据作为10进制整形来解读，之后可以当做整形来处理
- 字符串
  - 26进制表示法，转换为整数
  - a~z，对应0~25
  - code = c * 26^3 + o * 26^2 + d * 26^1 + e * 26^0
- 复合类型
  - 均可以转为整形
  - date，由year，month，day构成，拆分计算哈希值

### 设计原则
1. 一致性：如果a=b，那么hash(a) = hash(b)
2. 高效性：计算高效简便。哈希表是为了节省时间，因此，计算哈希值不应耗费太多时间，得不偿失
3. 均匀性：哈希值均匀分布

## 链地址法
当产生哈希冲突时，将插入的element挂载在已有node后面
- java 7: 哈希表每个位置有一个链表
- java 8：哈希表每个位置有一个链表，当哈希冲突过大时，转换为红黑树。可以将检索时间，链表的O(n)变为红黑树的O(logn)。 前提是，哈希表的Key是实现了`Comparable`接口的，因为红黑树有要求元素可以比。

## 动态空间
### 简单分析
假设
- 哈希表表长M
- 共存有元素N个

可得
- 若使用链表解决冲突，查询时间复杂度为O(N/M)
- 若使用平衡树解决冲突，查询时间复杂度为O(log(N/M))
- 最坏情况，N个元素全部冲突，上述两个复杂度分别退化为：链表O(N)，树O(logN)

**哈希碰撞攻击**， 得知hash code的具体算法后，可以设计一套数据，可以造成全量哈希冲突。从而造成哈希表退化为一棵树或者一个链表
### Resize
- 当`N >= upper * M`时，需要扩容
- 当`N < lower * M`时，需要缩容

操作步骤
1. 创建一个新的size的数组
2. 将原有的数据逐个rehashing之后存入
3. 将底层数组替换

rehashing有一个陷阱： **计算的时候需要使用新数组的长度取模**

## 复杂度分析
### 平均复杂度
平均复杂度O(1)，实际是处于 O(lower*M) ~ O(upper*M) 之间。  
与表长M成线性比例，可以认为是常数关系
### 扩容的size选择
1. 简单的*2，会导致哈希碰撞的概率增加
2. 使用prime表，每次扩容后，表长变为下一个区间推荐的素数长度

### 缺点
哈希表牺牲了数据的顺序性，无论底层使用链表或树实现链地址

## 开放地址法
相比于链地址法，有另一种方法解决哈希冲突。开放地址法中，哈希表直接存储元素，而非某种数据结构（链表或树）
1. 线性探测：哈希冲突后，查找元素位置+1，以此类推
2. 平方探测：哈希冲突后，查找元素位置+ x^2，x可以从1开始递增
3. 二次哈希：哈希冲突后，用另一个哈希函数